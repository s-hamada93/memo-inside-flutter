---
title: Inside Flutter
---


# Aggressive Composability

Flutterの最も特徴的な点のひとつは「積極的な構成可能性」です。
Widgetは他のWidgetを合成することで作られ、そのWidget自体も徐々に基本的なWidgetから作られます。
例えば、`Padding`は他のWidgetのプロパティではなくWidgetです。
その結果、Flutterで作られるユーザーインターフェースは、たくさんのWidgetで構成されます。

Widget構築の再帰は、「RenderObjectWidgets」で終了します。これは、基礎である「renderツリー」にノードを作成するWidgetです。
renderツリーは、ユーザーインターフェイスのジオメトリを格納するデータ構造であり、layout中に計算され、「painting」および「hit testing」中に使用されます。
ほとんどのFlutter開発者は、直接 render object を作成せず、代わりにWidgetを使用してrenderツリーを操作します。

Widgetレイヤーでの積極的な合成可能性をサポートするために、FlutterはWidgetレイヤーとrenderツリーレイヤーの両方で多くの効率的なアルゴリズムと最適化を使用しています。

## Sublinear Layout

多数のWidgetとレンダーオブジェクトがあるとき、優れたパフォーマンスの鍵となるのは効率的なアルゴリズムです。
最も重要なのは、レンダーオブジェクトのジオメトリ（例えば、サイズや位置）を決定するアルゴリズムである「layout」のパフォーマンスです。
他のツールキットの中には、O(N²)やそれより悪いレイアウトアルゴリズムを使用しているものもあります（例えば、ある制約領域での不動点反復法）。
Flutterは、初期レイアウトの線形なパフォーマンスと、既存のレイアウトを更新する一般的なケースにおける「劣線形なレイアウトパフォーマンス」を目指しています。
一般的に、レイアウトに費やされる時間は、レンダーオブジェクトの数よりも緩やかにスケールするはずです。

Flutterは1フレームにつき1回レイアウトを行い、レイアウトアルゴリズムは一度の通過で処理されます。
「constraint」は、親オブジェクトがそれぞれの子オブジェクトのlayoutメソッドを呼び出すことでツリーの下へと渡されていきます。
子オブジェクトは再帰的に自身のlayoutを実行し、そのlayoutメソッドから戻ることでツリーの上へと「geometry」を返します。
重要なのは、レンダーオブジェクトが一度layoutメソッドからリターンすると、次のフレームのレイアウトが行われるまで、そのレンダーオブジェクトは再び訪問されない[1]ことです。
このアプローチでは、計測の通過とレイアウトの通過の別々の通過を1つの通過に統合し、その結果、各レンダーオブジェクトはレイアウト中に最大2回訪問されます[2]。
ツリーを下るときに1回、ツリーを上るときに1回です。

<details><summary>※[1]:</summary>

少なくともレイアウトについてはです。ペイントのため、必要であればアクセシビリティ・ツリーを構築するため、必要であればヒットテストのために、再訪問されるかもしれません。
</details>


<details><summary>※[2]:</summary>

現実はもちろん、少し複雑です。いくつかのレイアウトには、固有の寸法（テキストや画像のようにそれ自身の内容によってサイズが定まるもの）やベースラインの測定が関係しており、これには関連するサブツリーの追加の巡回が含まれます（最悪の場合の2次関数的性能の可能性を緩和するために積極的なキャッシングが使用されます）。ただし、これらのケースは驚くほど稀です。特に、固有の寸法はshrink-wrappingの一般的なケースでは必要ありません。
</details>


Flutterはこの一般的なプロトコルにいくつかの特殊化を施しています。
最も一般的な特殊化は `RenderBox` で、2次元の直交座標で動作します。
ボックスレイアウトでは、制約は幅の最小値と最大値、高さの最小値と最大値です。
レイアウトする間、子はこれらの境界内でサイズを選択することによって、そのジオメトリを決定します。
子がレイアウトから戻った後、親は親の座標系における子の位置を決定します[3]。
子の位置は、子がレイアウトから戻った後でないと決定されないため、子のレイアウトはその位置に依存できないことに注意してください。
その結果、親は子のレイアウトを再計算する必要なく、子の位置を自由に変更できます。

<details><summary>※[3]:</summary>

技術的には、子供の位置はそのRenderBoxのジオメトリの一部ではなく、したがってレイアウト中に実際に計算する必要はありません。
多くのRenderオブジェクトは、自身の原点に対してその単一の子供を暗黙的に位置づけ、全く計算やストレージが必要ありません。
一部のRenderオブジェクトは、（例えば、paintフェーズ中など）それに続く描画がない場合には、計算を避けるために、子供の位置を最後の瞬間まで計算しません。
</details>

より一般的には、レイアウト中、親から子へ流れる唯一の情報は制約であり、子から親へ流れる唯一の情報はジオメトリです。
これらの不変の条件によって、レイアウト中に必要な作業量を減らすことができます：

* もし子が自身のレイアウトをdirty（変更があった状態）としてマークしていなければ、親が前回のレイアウト時に子が受け取った制約と同じ制約を子に与えている限り、子はレイアウトから直ちに戻ることができ、その先の巡回を打ち切ることができます。

* 親が子のレイアウトメソッドを呼び出すときはいつでも、親は子から返されるサイズ情報を使用するかどうかを示します。
親がサイズ情報を使用しない（これはよくあることである）場合、親は子が新しいサイズを選択しても、既存の制約に従うことが保証されているため、自身のレイアウトを再計算する必要はありません。

* タイトな（厳しい）制約とは、ちょうど1つの有効なジオメトリで満たすことができる制約のことです。
例えば、最小幅と最大幅が互いに等しく、最小高さと最大高さが互いに等しい場合、これらの制約を満たすサイズはそのような幅と高さを持つ唯一つに限られます。
親がタイトな制約を提供する場合、親がレイアウトで子のサイズを使用する場合でも、子がレイアウトを再計算するたびに親がレイアウトを再計算する必要はありません。

* レンダーオブジェクトは、そのジオメトリを決定するために親によって提供された制約のみを使用することを宣言できます。
このような宣言は、子オブジェクトがレイアウトを再計算するときに、レンダーオブジェクトの親がレイアウトを再計算する必要がないことをフレームワークに知らせます。

これらの最適化の結果、レンダーオブジェクトツリーにdirtyノードが含まれる場合、レイアウト中に訪問されるのは、それらのノードとその周りのサブツリーの限られた部分だけになります。

## Sublinear Widget Building

レイアウトアルゴリズムと同様に、FlutterのWidget構築アルゴリズムは劣線形です。
buildされた後、Widgetは「エレメントツリー」によって保持され、ユーザーインターフェイスの論理構造を保持します。
エレメントツリーが必要な理由は、Widget自体がイミュータブル（不変）であるためです。これは、他のWidgetとの親子関係を覚えることができないことを含みます。
エレメントツリーはまた、Stateful Widgetに関連付けられたstateオブジェクトを保持します。

ユーザー入力（あるいはその他の刺激）に対応して、エレメントはdirtyになることがあります。例えば、開発者が（そのエレメントに）関連しているstateオブジェクトにsetState()を呼び出した場合です。
フレームワークはdirtyなエレメントのリストを保持し、buildフェーズ中にこれらのエレメントに直接ジャンプし、cleanなエレメントをスキップします。
buildフェーズ中、情報はエレメントツリーを下方向に一方向に流れるため、各エレメントはbuildフェーズ中に最大で1回訪問されます。
一度きれいにされたエレメントは、帰納法により、その祖先がすべてきれいであるため、再び汚れることはありません[4]。

<details><summary>※[4]:</summary>

このルールには1つ例外があります。Building widgets on demandセクションで説明したように、一部のWidgetは、レイアウト制約の変更の結果として再構築されることがあります。Widgetが、レイアウト制約の変更の影響を受けるのと同じフレームで、無関係な理由でそれ自身をダーティにマークした場合、2回更新されます。この冗長なビルドは、Widget自体に限定され、その子孫には影響しません。
</details>

Widgetは変更不可能（immutable）であるため、エレメントが自身を変更された（dirty）とマークしていない場合、親が同一のWidgetでエレメントをrebuildすると、エレメントは直ちにbuildから戻ることができ、巡回を中断することができます。
さらに、エレメントは新しいWidgetが古いWidgetと同じであることを立証するために、2つのWidget参照のオブジェクトの同一性を比較するだけで済みます。
開発者は、この最適化を利用して、reprojectionパターンを実装します。このパターンでは、Widgetはビルド内のメンバー変数として格納された事前に構築された子Widgetを含みます。

ビルドの間、FlutterはInheritedWidgetsを使用して親チェーンをたどることもまた避けます。
Widgetが通常、たとえば現在のテーマカラーを決定するために親チェーンをたどる場合、ツリーの深さに応じてビルドフェーズはO(N²)になります。これは積極的な構築の使用によってかなり大きくなる可能性があります。
これらの親辿りを避けるために、フレームワークは各エレメントでInheritedWidgetのハッシュテーブルを維持することによって情報をエレメントツリーに下方にプッシュします。
通常、多くの要素が同じハッシュテーブルを参照し、新しいInheritedWidgetを導入するエレメントでのみ変更されます。

## Linear Reconsilation

一般的な信条とは異なり、Flutterはtree-diffing（木の差分）アルゴリズムを採用していません。
代わりに、フレームワークはO(N)のアルゴリズムを使用して、各要素の子リストを個別に調べることで、要素を再利用するかどうかを決定します。
子リストの照合アルゴリズムは、次のケースに最適化されています：

* 古い子リストが空である場合。
* 両方のリストが同一である場合。
* リスト内のちょうど1ヶ所で1つ以上のWidgetが挿入または削除されている場合。
* 同じキーを持つWidgetがそれぞれのリストに含まれている場合[5]、2つのWidgetが一致します。

<details><summary>※[5]:</summary>

キーは、Widgetに任意で関連付けられたopaque object（不透明オブジェクト：不特定な型のオブジェクト）であり、その等価演算子は照合アルゴリズムに影響を与えるために使用されます。
</details>

一般的なアプローチは、各Widgetの実行時の型とキーを比較して、両方の子リストの先頭と末尾を対応させ、各リストの中間に一致しない子が含まれる可能性のある空でない範囲を見つけることです。
その後、フレームワークは、古い子リストの範囲内の子をキーに基づいてハッシュテーブルに配置します。
次に、フレームワークは新しい子リストの範囲を巡回し、一致するものをキーでハッシュテーブルからクエリします。
一致しない子は破棄されてゼロから再構築される一方で、一致した子は新しいWidgetで再構築されます。